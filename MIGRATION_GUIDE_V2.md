# Migration Guide: Lockbox v1 â†’ v2 (Password Manager)

## Overview

This guide covers the migration path from the current single-PDA 1KB storage system to the multi-tier password manager architecture.

## Migration Strategy

### Phase 1: Dual-Version Support (Months 1-2)

#### Deploy New Program Version
```bash
# Build new program
anchor build --program-name lockbox_v2

# Deploy alongside v1
anchor deploy --program-name lockbox_v2

# Update program IDs
export LOCKBOX_V1=5nr7xe1U3k6U6zPEmW3FCbPyXCa7jr7JpudaLKuVNyvZ
export LOCKBOX_V2=<NEW_PROGRAM_ID>
```

#### Maintain Backward Compatibility
```rust
// Support both v1 and v2 accounts
pub mod lockbox_v2 {
    use super::*;

    pub fn migrate_from_v1(
        ctx: Context<MigrateFromV1>,
    ) -> Result<()> {
        let v1_account = &ctx.accounts.v1_lockbox;
        let v2_master = &mut ctx.accounts.v2_master_lockbox;

        // Read v1 data
        let v1_data = LockboxV1::try_deserialize(&mut v1_account.data.borrow_mut().as_ref())?;

        // Initialize v2 master account
        v2_master.owner = v1_data.owner;
        v2_master.total_entries = 1; // v1 had single entry
        v2_master.subscription_tier = SubscriptionTier::Free;
        v2_master.last_accessed = Clock::get()?.unix_timestamp;

        // Create first storage chunk with v1 data
        let chunk = &mut ctx.accounts.first_chunk;
        chunk.master_lockbox = v2_master.key();
        chunk.owner = v1_data.owner;
        chunk.chunk_index = 0;
        chunk.max_capacity = 1024;
        chunk.current_size = v1_data.ciphertext.len() as u32;

        // Copy encrypted data
        chunk.encrypted_data = v1_data.ciphertext;

        // Create entry header
        chunk.entry_headers.push(DataEntryHeader {
            entry_id: 1,
            offset: 0,
            size: v1_data.ciphertext.len() as u32,
            entry_type: PasswordEntryType::Login,
            category: 0, // Default category
            title_hash: [0; 32], // Will be generated by client
            created_at: v1_data.last_action_slot as i64,
            last_modified: v1_data.last_action_slot as i64,
            access_count: 0,
            flags: 0,
        });

        // Register chunk in master
        v2_master.storage_chunks.push(StorageChunkInfo {
            chunk_address: chunk.key(),
            chunk_index: 0,
            max_capacity: 1024,
            size_used: v1_data.ciphertext.len() as u32,
            data_type: StorageType::Passwords,
            created_at: Clock::get()?.unix_timestamp,
            last_modified: Clock::get()?.unix_timestamp,
        });

        v2_master.storage_chunks_count = 1;
        v2_master.total_capacity = 1024;
        v2_master.storage_used = v1_data.ciphertext.len() as u64;

        emit!(MigrationCompleted {
            user: v1_data.owner,
            v1_account: v1_account.key(),
            v2_account: v2_master.key(),
        });

        Ok(())
    }
}

#[derive(Accounts)]
pub struct MigrateFromV1<'info> {
    #[account(
        seeds = [b"lockbox", owner.key().as_ref()],
        bump,
        seeds::program = LOCKBOX_V1_PROGRAM_ID,
    )]
    /// CHECK: V1 lockbox account (validated by seeds)
    pub v1_lockbox: AccountInfo<'info>,

    #[account(
        init,
        payer = owner,
        space = MasterLockbox::INIT_SPACE,
        seeds = [b"master_lockbox", owner.key().as_ref()],
        bump
    )]
    pub v2_master_lockbox: Account<'info, MasterLockbox>,

    #[account(
        init,
        payer = owner,
        space = StorageChunk::INIT_SPACE + 1024,
        seeds = [b"storage_chunk", v2_master_lockbox.key().as_ref(), &0u16.to_le_bytes()],
        bump
    )]
    pub first_chunk: Account<'info, StorageChunk>,

    #[account(mut)]
    pub owner: Signer<'info>,

    pub system_program: Program<'info, System>,
}
```

### Phase 2: Client-Side Migration (Months 2-3)

#### SDK Migration Helper
```typescript
class MigrationHelper {
  async migrateToV2(
    connection: Connection,
    wallet: WalletAdapter,
    v1ProgramId: PublicKey,
    v2ProgramId: PublicKey
  ): Promise<MigrationResult> {
    // 1. Check if v1 account exists
    const [v1Pda] = PublicKey.findProgramAddressSync(
      [Buffer.from('lockbox'), wallet.publicKey!.toBuffer()],
      v1ProgramId
    );

    const v1Account = await connection.getAccountInfo(v1Pda);
    if (!v1Account) {
      throw new Error('No v1 account found');
    }

    // 2. Decrypt v1 data
    const v1Data = await this.decryptV1Data(v1Account, wallet);

    // 3. Call migration instruction
    const [v2MasterPda] = PublicKey.findProgramAddressSync(
      [Buffer.from('master_lockbox'), wallet.publicKey!.toBuffer()],
      v2ProgramId
    );

    const [firstChunkPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from('storage_chunk'),
        v2MasterPda.toBuffer(),
        Buffer.from([0, 0]) // chunk index 0
      ],
      v2ProgramId
    );

    const program = new Program(LockboxV2IDL, v2ProgramId, { connection });

    const tx = await program.methods
      .migrateFromV1()
      .accounts({
        v1Lockbox: v1Pda,
        v2MasterLockbox: v2MasterPda,
        firstChunk: firstChunkPda,
        owner: wallet.publicKey!,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    // 4. Verify migration
    const v2Master = await program.account.masterLockbox.fetch(v2MasterPda);

    return {
      success: true,
      txSignature: tx,
      v1Account: v1Pda.toBase58(),
      v2Account: v2MasterPda.toBase58(),
      migratedData: v1Data,
      newAccountInfo: v2Master,
    };
  }

  private async decryptV1Data(
    account: AccountInfo<Buffer>,
    wallet: WalletAdapter
  ): Promise<DecryptedV1Data> {
    // Implement v1 decryption logic
    return {
      plaintext: '',
      nonce: new Uint8Array(),
      salt: new Uint8Array(),
    };
  }
}

interface MigrationResult {
  success: boolean;
  txSignature: string;
  v1Account: string;
  v2Account: string;
  migratedData: DecryptedV1Data;
  newAccountInfo: any;
}

interface DecryptedV1Data {
  plaintext: string;
  nonce: Uint8Array;
  salt: Uint8Array;
}
```

#### UI Migration Flow
```typescript
// Migration UI component
export function MigrationWizard() {
  const { connection } = useConnection();
  const wallet = useWallet();
  const [step, setStep] = useState(1);
  const [migrating, setMigrating] = useState(false);

  const handleMigrate = async () => {
    setMigrating(true);

    try {
      const helper = new MigrationHelper();
      const result = await helper.migrateToV2(
        connection,
        wallet,
        LOCKBOX_V1_PROGRAM_ID,
        LOCKBOX_V2_PROGRAM_ID
      );

      console.log('Migration successful:', result);
      setStep(3); // Success step
    } catch (error) {
      console.error('Migration failed:', error);
      alert('Migration failed. Please try again.');
    } finally {
      setMigrating(false);
    }
  };

  return (
    <div className="migration-wizard">
      <h2>Upgrade to Lockbox v2</h2>

      {step === 1 && (
        <div className="step-1">
          <h3>What's New in v2?</h3>
          <ul>
            <li>Store unlimited passwords (with Premium)</li>
            <li>Organize with categories and folders</li>
            <li>Search your encrypted vault</li>
            <li>Share passwords securely</li>
            <li>Password health dashboard</li>
          </ul>
          <button onClick={() => setStep(2)}>Start Migration</button>
        </div>
      )}

      {step === 2 && (
        <div className="step-2">
          <h3>Migration Process</h3>
          <p>This will:</p>
          <ol>
            <li>Read your existing encrypted data</li>
            <li>Create a new v2 account structure</li>
            <li>Transfer your data securely</li>
            <li>Keep your v1 account intact (optional cleanup later)</li>
          </ol>
          <button onClick={handleMigrate} disabled={migrating}>
            {migrating ? 'Migrating...' : 'Migrate Now'}
          </button>
        </div>
      )}

      {step === 3 && (
        <div className="step-3">
          <h3>Migration Complete!</h3>
          <p>Your data has been successfully migrated to Lockbox v2.</p>
          <button onClick={() => window.location.reload()}>
            Start Using v2
          </button>
        </div>
      )}
    </div>
  );
}
```

### Phase 3: Deprecation (Month 6+)

#### Sunset v1 Program
```rust
// After 6 months, add deprecation warnings
pub fn store_encrypted_v1(ctx: Context<StoreV1>) -> Result<()> {
    msg!("WARNING: Lockbox v1 is deprecated. Please migrate to v2 at lockbox.sol/migrate");

    // Still functional but warn users
    // ... existing v1 logic

    Ok(())
}
```

#### Close v1 Accounts
```rust
// Allow users to close v1 accounts after migration
pub fn close_v1_account(ctx: Context<CloseV1>) -> Result<()> {
    let v1_account = &ctx.accounts.v1_lockbox;
    let owner = &ctx.accounts.owner;

    // Verify ownership
    require!(
        v1_account.owner == owner.key(),
        ErrorCode::Unauthorized
    );

    // Verify migration completed (v2 account exists)
    let [v2_pda, _] = Pubkey::find_program_address(
        &[b"master_lockbox", owner.key().as_ref()],
        ctx.program_id,
    );
    let v2_account = ctx.accounts.v2_master_lockbox.key();
    require!(v2_account == v2_pda, ErrorCode::MigrationNotComplete);

    // Close v1 account and return rent
    let dest = owner.to_account_info();
    let source = v1_account.to_account_info();

    **dest.lamports.borrow_mut() = dest
        .lamports()
        .checked_add(source.lamports())
        .unwrap();
    **source.lamports.borrow_mut() = 0;

    Ok(())
}
```

## Data Format Changes

### V1 Data Structure
```rust
pub struct LockboxV1 {
    pub owner: Pubkey,              // 32 bytes
    pub ciphertext: Vec<u8>,        // Variable (max 1024)
    pub nonce: [u8; 24],            // 24 bytes
    pub salt: [u8; 32],             // 32 bytes
    pub last_action_slot: u64,      // 8 bytes
    pub bump: u8,                   // 1 byte
}
```

### V2 Data Structure
```rust
pub struct MasterLockbox {
    pub owner: Pubkey,              // 32 bytes
    pub total_entries: u64,         // 8 bytes
    pub storage_chunks_count: u16,  // 2 bytes
    pub subscription_tier: SubscriptionTier, // 1 byte
    pub last_accessed: i64,         // 8 bytes
    pub subscription_expires: i64,  // 8 bytes
    pub total_capacity: u64,        // 8 bytes
    pub storage_used: u64,          // 8 bytes
    pub storage_chunks: Vec<StorageChunkInfo>, // Variable
    pub encrypted_index: Vec<u8>,   // Variable
    pub bump: u8,                   // 1 byte
}
```

## Client-Side Changes

### Old SDK Usage
```typescript
// v1 SDK
const client = new LockboxClient({ connection, wallet });
await client.store('my secret data');
const data = await client.retrieve();
```

### New SDK Usage
```typescript
// v2 SDK
const client = new LockboxV2Client({ connection, wallet });

// Store with metadata
await client.storePassword({
  title: 'GitHub Account',
  username: 'user@example.com',
  password: 'secure_password_123',
  url: 'https://github.com',
  category: 'Work',
  tags: ['development', 'important'],
});

// Retrieve with filtering
const passwords = await client.getPasswords({
  category: 'Work',
  tags: ['important'],
});

// Search
const results = await client.search('github');
```

## Testing Migration

### Local Testing
```bash
# 1. Deploy v1 program to localnet
anchor deploy --program-name lockbox

# 2. Create test v1 account
anchor run test-v1-create

# 3. Deploy v2 program
anchor deploy --program-name lockbox_v2

# 4. Test migration
anchor run test-migration

# 5. Verify data integrity
anchor run verify-migration
```

### Devnet Testing
```bash
# 1. Create test accounts on devnet
npm run test:devnet:create-v1-accounts

# 2. Deploy v2 to devnet
anchor deploy --provider.cluster devnet --program-name lockbox_v2

# 3. Run migration tests
npm run test:devnet:migrate

# 4. Verify
npm run test:devnet:verify
```

## Rollback Plan

If migration fails:

1. **Immediate**: V1 accounts remain functional
2. **Data Safety**: All v1 data preserved
3. **Retry**: Users can attempt migration again
4. **Support**: Manual migration assistance available

## Timeline

- **Month 1**: Deploy v2, begin beta testing
- **Month 2**: Open migration to all users
- **Month 3**: Majority migrated, UI updates
- **Month 4-5**: Encourage remaining users
- **Month 6**: Deprecation warnings
- **Month 12**: Consider shutting down v1

## Support Resources

- Migration FAQ: [docs.lockbox.sol/migration](https://docs.lockbox.sol/migration)
- Video tutorial: [youtube.com/lockbox-migration](https://youtube.com)
- Discord support: [discord.gg/lockbox](https://discord.gg)
- Email: support@lockbox.sol

## Frequently Asked Questions

### Will I lose my data during migration?
No. Your v1 account remains intact. Migration creates a new v2 account with a copy of your data.

### Can I still use v1 after migration?
Yes, but we recommend using v2 for new features and better security.

### What happens if migration fails?
Your v1 account is untouched. You can retry migration or contact support.

### Do I need to pay for migration?
Migration itself is free. You only pay standard Solana transaction fees (~$0.0001).

### How long does migration take?
Usually 5-10 seconds for the transaction to confirm.

### Can I migrate multiple accounts?
Yes, each wallet can migrate its associated lockbox.

### What if I have a Premium subscription?
Your subscription status will be preserved in v2.

## Conclusion

The migration from v1 to v2 is designed to be smooth, safe, and user-friendly. We've prioritized data integrity and backward compatibility to ensure a seamless transition to the enhanced password manager features.

For assistance, please reach out to our support team or community.
